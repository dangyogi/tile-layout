# layouts.yaml

---

lay_row:
    description: >
      Lays one row of tile.  If count is provided, that many tiles are layed.  Otherwise,
      the row will extend to the right edge of the wall.
    parameters: [step, num_x]
    defaults:
        num_x: null
    constants:
        increment_x: plan.get_inc_xy(step, constants)[0]
    type: repeat
    step: step
    increment: [increment_x, 0]
    times: num_x

stepped:
    description: >
      A stepped pattern with each row starting at an offset from the prior row.

      The offset is percent_offset * the width of the tile (including the grout_gap).
      
      The percent_offset defaults to 0 (for a stacked pattern).
    parameters: [step, percent_offset, num_x, num_y]
    defaults:
        percent_offset: 0
        num_x: null
        num_y: null
    constants:
        increment_xy: plan.get_inc_xy(step, constants)
        x: increment_xy[0]
        y: increment_xy[1]
        conditionals:
            - test: percent_offset == 0
              true:
                x_inc: 0
              false:
                x_inc: x * percent_offset - x
    type: repeat
    step:
        type: lay_row
        step: step
        times: num_x
    increment: [x_inc, y]
    times: num_y

hopscotch:
    description: >
      A hopscotch pattern.

      If right is true tile_b is placed to right (clockwise) of each corner of tile_a.

      If right is false tile_b is placed to left (counter-clockwise) of each corner of
      tile_a.

      Note that reversing the order of the tiles also reverses right/left.
    parameters: [tile_a, tile_b, right]
    defaults:
        right: false
    constants:
        ax: multi_getattr(tile_a, 'skip_x') + plan.grout_gap
        a_skip_y: multi_getattr(tile_a, 'skip_y')
        ay: a_skip_y + plan.grout_gap
        bx: multi_getattr(tile_b, 'skip_x') + plan.grout_gap
        b_skip_y: multi_getattr(tile_b, 'skip_y')
        by: b_skip_y + plan.grout_gap
        conditionals:
            - test: right
              true:
                  inc: [ax, -by]
                  b_placement: [-bx, 0]
                  outer_inc: [-(ax - bx), ay + by]
              false:
                  inc: [ax + bx, -(ay - by)]
                  b_placement: [0, -by]
                  outer_inc: [-bx, ay]
    type: repeat
    step:
        type: sequence
        steps:
            - type: repeat
              step:
                  type: place
                  tile: tile_a
              increment: inc
            - type: repeat
              step:
                  type: place
                  tile: tile_b
              start: b_placement
              increment: inc
    increment: outer_inc

herringbone:
    description: >
      A herringbone pattern.

      If right is true the flipped tile is placed to right (clockwise) from each corner
      of the original tile.

      If right is false the flipped tile is placed to left (counter-clockwise) from each
      corner of the original tile.
    parameters: [tile, right]
    defaults:
        right: true
    type: hopscotch
    tile_a: tile
    tile_b: tile.flipped
    right: right

box:
    description: >
      A solid rectangle of tiles num_x tiles wide, and num_y tiles high.
    parameters: [tile, num_x, num_y, start]
    defaults:
        num_x: null
        num_y: null
        start: [0, 0]
    type: repeat
    step:
        type: repeat
        step:
            type: place
            tile: tile
        increment: ["multi_getattr(tile, 'skip_x') + plan.grout_gap", 0]
        times: num_x
    increment: [0, "multi_getattr(tile, 'skip_y') + plan.grout_gap"]
    times: num_y
    start: start

checkerboard:
    description: >
      A rectangle filled with tiles cycling both horizontally and vertically.
    parameters: [tiles, num_x, num_y, start]
    defaults:
        num_x: null
        num_y: null
        start: [0, 0]
    type: repeat
    step:
        type: repeat
        step:
            type: place
            tile: tiles
        increment: ["multi_getattr(tiles, 'skip_x') + plan.grout_gap", 0]
        times: num_x
        index_start: index
    increment: [0, "multi_getattr(tiles, 'skip_y') + plan.grout_gap"]
    times: num_y
    start: start

border:
    description: >
      A border of single tiles num_x tiles wide, and num_y tiles high.
    parameters: [tile, num_x, num_y, start_x, start_y]
    defaults:
        start_x: 0
        start_y: 0
    constants:
        x: multi_getattr(tile, 'skip_x') + plan.grout_gap
        y: multi_getattr(tile, 'skip_y') + plan.grout_gap
    type: sequence
    steps:
        - type: repeat  # bottom
          step:
              type: place
              tile: tile
          increment: [x, 0]
          start: [start_x, start_y]
          times: num_x
        - type: repeat  # top
          step:
              type: place
              tile: tile
          increment: [x, 0]
          start: [start_x,
                  start_y + y * (num_y - 1)]
          times: num_x
        - type: repeat  # left
          step:
              type: place
              tile: tile
          increment: [0, y]
          start: [start_x, start_y + y]
          times: num_y - 2
        - type: repeat  # right
          step:
              type: place
              tile: tile
          increment: [0, y]
          start: [start_x + x * (num_x - 1), start_y + y]
          times: num_y - 2

flower:
    description: >
      Four tiles in a square (2x2 tiles) all sharing the lower-right corner of the
      original tile.
    parameters: [tile]
    type: sequence
    steps:
        - type: place
          tile: tile
          angle: 90
          index: 3
          save:
              inc_x: inc_x
              inc_y: inc_y
        - type: place
          tile: tile
          angle: 180
          index: 2
          offset: [inc_x, 0]
        - type: place
          tile: tile
          angle: 0
          index: 0
          offset: [0, inc_y]
        - type: place
          tile: tile
          angle: -90
          index: 1
          offset: [inc_x, inc_y]
