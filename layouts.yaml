# layouts.yaml

---

lay_row:
    description: >
      Lays one row of the `step` pattern.  If count is provided, that many tiles are layed.
      Otherwise, the row will extend to the left and right edges of the wall.
    parameters: [step, num_x]
    defaults:
        num_x: null
    constants:
        increment_x: plan.get_inc_xy(step, constants)[0]
    type: repeat
    step: step
    increment: [increment_x, 0]
    times: num_x

stepped:
    description: >
      A stepped pattern with each row starting at an offset from the prior row.

      The offset is percent_offset * the width of the `step` (including the grout_gap).
      
      The percent_offset defaults to 0 (for a stacked pattern).
    parameters: [step, percent_offset, num_x, num_y]
    defaults:
        percent_offset: 0
        num_x: null
        num_y: null
    constants:
        increment_xy: plan.get_inc_xy(step, constants)
        x: increment_xy[0]
        y: increment_xy[1]
        conditionals:
            - test: percent_offset == 0
              true:
                x_inc: 0
              false:
                x_inc: x * percent_offset - x
    type: repeat
    step:
        type: lay_row
        step: step
        times: num_x
    increment: [x_inc, y]
    times: num_y

hopscotch:
    description: >
      A hopscotch pattern.

      If right is true step_b is placed to right (clockwise) of each corner of step_a.

      If right is false step_b is placed to left (counter-clockwise) of each corner of
      step_a.

      Note that reversing the order of the steps also reverses right/left.
    parameters: [step_a, step_b, right]
    defaults:
        right: false
    constants:
        aincrement_xy: plan.get_inc_xy(step_a, constants)
        ax: aincrement_xy[0]
        ay: aincrement_xy[1]
        bincrement_xy: plan.get_inc_xy(step_b, constants)
        bx: bincrement_xy[0]
        by: bincrement_xy[1]
        conditionals:
            - test: right
              true:
                  inc: [ax, -by]
                  b_placement: [-bx, 0]
                  outer_inc: [-(ax - bx), ay + by]
              false:
                  inc: [ax + bx, -(ay - by)]
                  b_placement: [0, -by]
                  outer_inc: [-bx, ay]
    type: repeat
    step:
        type: sequence
        steps:
            - type: repeat
              step: step_a
              increment: inc
            - type: repeat
              step: step_b
              start: b_placement
              increment: inc
    increment: outer_inc

herringbone:
    description: >
      A herringbone pattern.

      If right is true the tile_vert is placed to right (clockwise) from each corner
      of the tile_horz.

      If right is false the vert_tile_vert is placed to left (counter-clockwise) from each
      corner of the tile_horz.
    parameters: [tile_horz, tile_vert, right]
    defaults:
        right: true
        tile_vert: tile_horz.flipped
    type: hopscotch
    step_a:
        type: place
        tile: tile_horz
    step_b:
        type: place
        tile: tile_vert
    right: right

basketweave:
    description: >
      A basketweave pattern.  This is a double herringbone, where each tile is doubled.

      If right is true the tile_vert is placed to right (clockwise) from each corner
      of the tile_horz.

      If right is false the vert_tile_vert is placed to left (counter-clockwise) from each
      corner of the tile_horz.
    parameters: [tile_horz, tile_vert, num_horz, num_vert, right]
    defaults:
        right: true
        tile_vert: tile_horz.flipped
        num_horz: 2
        num_vert: 2
    type: hopscotch
    step_a:
        type: repeat
        step:
            type: place
            tile: tile_horz
        increment: [0, "multi_getattr(tile_horz, 'skip_y') + plan.grout_gap"]
        times: num_horz
    step_b:
        type: repeat
        step:
            type: place
            tile: tile_vert
        increment: ["multi_getattr(tile_vert, 'skip_x') + plan.grout_gap", 0]
        times: num_vert
    right: right

do_new_basketweave:
    description: >
        Rect_a and rect_b should be rotated 90 degrees from each other for the horizontal
        and vertical strands of the basketweave.

        The tile_square takes up the space in the corners left by the different vertical
        and horizontal dimensions of the rectangles.  The size of the square should be the
        difference in dimensions / 2 minus one grout_gap.
    parameters: [rect_a, rect_b, tile_square]
    constants:
        ainc: plan.get_inc_xy(rect_a, constants, "rect_a")
        ainc_x: ainc[0]
        ainc_y: ainc[1]
        binc: plan.get_inc_xy(rect_b, constants, "rect_b")
        binc_x: binc[0]
        binc_y: binc[1]
    type: sequence
    steps:
        - type: repeat
          step:
              type: sequence
              steps:
                  - type: repeat
                    step: rect_a
                    increment: [ainc_x + binc_x, 0]
                  - type: repeat
                    step: rect_b
                    increment: [ainc_x + binc_x, 0]
                    offset: [ainc_x, (ainc_y - binc_y) / 2]
          increment: [-ainc_x + (ainc_x - binc_x) / 2, (ainc_y + binc_y) / 2]
        - type: repeat
          step:
              type: repeat
              step:
                  type: place
                  tile: tile_square
              increment: [binc_x + square_inc_x, 0]
          increment: [0, square_inc_y + ainc_y]
          use:
              square_inc_x: multi_getattr(tile_square, 'skip_x') + plan.grout_gap
              square_inc_y: multi_getattr(tile_square, 'skip_y') + plan.grout_gap
              offset_y: ainc_y
          skip: tile_square is None

new_basketweave:
    description: |
        For the size of tile_square:

        rect_a_height = num_strands * tile_horz.height + (num_strands - 1) * grout_gap
        rect_b_height = tile_vert.height

        tile_square.height = abs(rect_a_height - rect_b_height) / 2 - grout_gap
    parameters: [tile_horz, tile_vert, num_strands, tile_square]
    defaults:
        tile_vert: tile_horz.flipped
    type: do_new_basketweave
    rect_a:
        type: repeat
        step:
            type: place
            tile: tile_horz
        increment: [0, "multi_getattr(tile_horz, 'skip_y') + plan.grout_gap"]
        times: num_strands
    rect_b:
        type: repeat
        step:
            type: place
            tile: tile_vert
        increment: ["multi_getattr(tile_vert, 'skip_x') + plan.grout_gap", 0]
        times: num_strands
    tile_square: tile_square

new_basketweave_mixed:
    description: |
        For the size of tile_square:

        rect_a_height = num_strands * tile_horz.height + (num_strands - 1) * grout_gap
        rect_b_height = tile_vert.height

        tile_square.height = abs(rect_a_height - rect_b_height) / 2 - grout_gap
    parameters: [tile_a, tile_b, tile_c, tile_square]
    type: do_new_basketweave
    rect_a:
        type: mixed_vert
        tile_a: tile_a
        tile_b: tile_b
        tile_c: tile_c
    rect_b:
        type: mixed_horz
        tile_a: tile_a.flipped
        tile_b: tile_b.flipped
        tile_c: tile_c.flipped
    tile_square: tile_square

mixed_vert:
    parameters: [tile_a, tile_b, tile_c]
    constants:
        ainc_y: tile_a.skip_y + plan.grout_gap
        binc_y: tile_b.skip_y + plan.grout_gap
    type: sequence
    steps:
        - type: place
          tile: tile_a
        - type: place
          tile: tile_b
          offset: [0, ainc_y]
        - type: place
          tile: tile_c
          offset: [0, ainc_y + binc_y]

mixed_horz:
    parameters: [tile_a, tile_b, tile_c]
    constants:
        ainc_x: tile_a.skip_x + plan.grout_gap
        binc_x: tile_b.skip_x + plan.grout_gap
    type: sequence
    steps:
        - type: place
          tile: tile_a
        - type: place
          tile: tile_b
          offset: [ainc_x, 0]
        - type: place
          tile: tile_c
          offset: [ainc_x + binc_x, 0]

box:
    description: >
      A solid rectangle of `step`s num_x steps wide, and num_y steps high.
    parameters: [step, num_x, num_y, start]
    defaults:
        num_x: null
        num_y: null
        start: [0, 0]
    constants:
        increment_xy: plan.get_inc_xy(step, constants)
        x: increment_xy[0]
        y: increment_xy[1]
    type: repeat
    step:
        type: repeat
        step: step
        increment: [x, 0]
        times: num_x
    increment: [0, y]
    times: num_y
    start: start

checkerboard:
    description: >
      A rectangle filled with steps cycling both horizontally and vertically.
    parameters: [steps, num_x, num_y, start]
    defaults:
        num_x: null
        num_y: null
        start: [0, 0]
    constants:
        increment_xy: plan.get_inc_xy(steps, constants)
        x: increment_xy[0]
        y: increment_xy[1]
    type: repeat
    step:
        type: repeat
        step: steps
        increment: [x, 0]
        times: num_x
        index_start: index
    increment: [0, y]
    times: num_y
    start: start

border:
    description: >
      A border of single steps num_x steps wide, and num_y steps high.
    parameters: [step, num_x, num_y, start_x, start_y]
    defaults:
        start_x: 0
        start_y: 0
    constants:
        increment_xy: plan.get_inc_xy(step, constants)
        x: increment_xy[0]
        y: increment_xy[1]
    type: sequence
    steps:
        - type: repeat  # bottom
          step: step
          increment: [x, 0]
          start: [start_x, start_y]
          times: num_x
        - type: repeat  # top
          step: step
          increment: [x, 0]
          start: [start_x,
                  start_y + y * (num_y - 1)]
          times: num_x
        - type: repeat  # left
          step: step
          increment: [0, y]
          start: [start_x, start_y + y]
          times: num_y - 2
        - type: repeat  # right
          step: step
          increment: [0, y]
          start: [start_x + x * (num_x - 1), start_y + y]
          times: num_y - 2

flower:
    description: >
      Four tiles in a square (2x2 tiles) all sharing the lower-right corner of the
      original tile.
    parameters: [tile]
    type: sequence
    steps:
        - type: place
          tile: tile
          angle: 90
          index: 3
          save:
              inc_x: inc_x
              inc_y: inc_y
        - type: place
          tile: tile
          angle: 180
          index: 2
          offset: [inc_x, 0]
        - type: place
          tile: tile
          angle: 0
          index: 0
          offset: [0, inc_y]
        - type: place
          tile: tile
          angle: -90
          index: 1
          offset: [inc_x, inc_y]
