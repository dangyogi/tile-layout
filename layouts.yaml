# layouts.yaml

---

lay_row:
    description: >
      Lays one row of the `step` pattern.  If count is provided, that many tiles are layed.
      Otherwise, the row will extend to the left and right edges of the wall.
    parameters: [step, num_x]
    defaults:
        num_x: null
    constants:
        increment_x: plan.get_inc_xy(step, constants)[0]
    type: repeat
    step: step
    increment: [increment_x, 0]
    times: num_x

stepped:
    description: >
      A stepped pattern with each row starting at an offset from the prior row.

      The offset is percent_offset * the width of the `step` (including the grout_gap).
      
      The percent_offset defaults to 0 (for a stacked pattern).
    parameters: [step, percent_offset, num_x, num_y]
    defaults:
        percent_offset: 0
        num_x: null
        num_y: null
    constants:
        increment_xy: plan.get_inc_xy(step, constants)
        x: increment_xy[0]
        y: increment_xy[1]
        conditionals:
            - test: percent_offset == 0
              true:
                x_inc: 0
              false:
                x_inc: x * percent_offset - x
    type: repeat
    step:
        type: lay_row
        step: step
        times: num_x
    increment: [x_inc, y]
    times: num_y

hopscotch:
    description: >
      A hopscotch pattern.

      If right is true step_b is placed to right (clockwise) of each corner of step_a.

      If right is false step_b is placed to left (counter-clockwise) of each corner of
      step_a.

      Note that reversing the order of the steps also reverses right/left.
    parameters: [step_a, step_b, right]
    defaults:
        right: false
    constants:
        aincrement_xy: plan.get_inc_xy(step_a, constants)
        ax: aincrement_xy[0]
        ay: aincrement_xy[1]
        bincrement_xy: plan.get_inc_xy(step_b, constants)
        bx: bincrement_xy[0]
        by: bincrement_xy[1]
        conditionals:
            - test: right
              true:
                  inc: [ax, -by]
                  b_placement: [-bx, 0]
                  outer_inc: [-(ax - bx), ay + by]
              false:
                  inc: [ax + bx, -(ay - by)]
                  b_placement: [0, -by]
                  outer_inc: [-bx, ay]
    type: repeat
    step:
        type: sequence
        steps:
            - type: repeat
              step: step_a
              increment: inc
            - type: repeat
              step: step_b
              start: b_placement
              increment: inc
    increment: outer_inc

herringbone:
    description: >
      A herringbone pattern.

      If right is true the tile_vert is placed to right (clockwise) from each corner
      of the tile_horz.

      If right is false the vert_tile_vert is placed to left (counter-clockwise) from each
      corner of the tile_horz.
    parameters: [tile_horz, tile_vert, right]
    defaults:
        right: true
        tile_vert: tile_horz.flipped
    type: hopscotch
    step_a:
        type: place
        tile: tile_horz
    step_b:
        type: place
        tile: tile_vert
    right: right

basketweave:
    description: >
      A basketweave pattern.  This is a double herringbone, where each tile is doubled.

      If right is true the tile_vert is placed to right (clockwise) from each corner
      of the tile_horz.

      If right is false the vert_tile_vert is placed to left (counter-clockwise) from each
      corner of the tile_horz.
    parameters: [tile_horz, tile_vert, num_horz, num_vert, right]
    defaults:
        right: true
        tile_vert: tile_horz.flipped
        num_horz: 2
        num_vert: 2
    type: hopscotch
    step_a:
        type: repeat
        step:
            type: place
            tile: tile_horz
        increment: [0, tile_horz.skip_y + plan.grout_gap]
        times: num_horz
    step_b:
        type: repeat
        step:
            type: place
            tile: tile_vert
        increment: [tile_vert.skip_x + plan.grout_gap, 0]
        times: num_vert
    right: right

box:
    description: >
      A solid rectangle of `step`s num_x steps wide, and num_y steps high.
    parameters: [step, num_x, num_y, start]
    defaults:
        num_x: null
        num_y: null
        start: [0, 0]
    constants:
        increment_xy: plan.get_inc_xy(step, constants)
        x: increment_xy[0]
        y: increment_xy[1]
    type: repeat
    step:
        type: repeat
        step: step
        increment: [x, 0]
        times: num_x
    increment: [0, y]
    times: num_y
    start: start

checkerboard:
    description: >
      A rectangle filled with steps cycling both horizontally and vertically.
    parameters: [steps, num_x, num_y, start]
    defaults:
        num_x: null
        num_y: null
        start: [0, 0]
    constants:
        increment_xy: plan.get_inc_xy(steps, constants)
        x: increment_xy[0]
        y: increment_xy[1]
    type: repeat
    step:
        type: repeat
        step: steps
        increment: [x, 0]
        times: num_x
        index_start: index
    increment: [0, y]
    times: num_y
    start: start

border:
    description: >
      A border of single steps num_x steps wide, and num_y steps high.
    parameters: [step, num_x, num_y, start_x, start_y]
    defaults:
        start_x: 0
        start_y: 0
    constants:
        increment_xy: plan.get_inc_xy(step, constants)
        x: increment_xy[0]
        y: increment_xy[1]
    type: sequence
    steps:
        - type: repeat  # bottom
          step: step
          increment: [x, 0]
          start: [start_x, start_y]
          times: num_x
        - type: repeat  # top
          step: step
          increment: [x, 0]
          start: [start_x,
                  start_y + y * (num_y - 1)]
          times: num_x
        - type: repeat  # left
          step: step
          increment: [0, y]
          start: [start_x, start_y + y]
          times: num_y - 2
        - type: repeat  # right
          step: step
          increment: [0, y]
          start: [start_x + x * (num_x - 1), start_y + y]
          times: num_y - 2

flower:
    description: >
      Four tiles in a square (2x2 tiles) all sharing the lower-right corner of the
      original tile.
    parameters: [tile]
    type: sequence
    steps:
        - type: place
          tile: tile
          angle: 90
          index: 3
          save:
              inc_x: inc_x
              inc_y: inc_y
        - type: place
          tile: tile
          angle: 180
          index: 2
          offset: [inc_x, 0]
        - type: place
          tile: tile
          angle: 0
          index: 0
          offset: [0, inc_y]
        - type: place
          tile: tile
          angle: -90
          index: 1
          offset: [inc_x, inc_y]
